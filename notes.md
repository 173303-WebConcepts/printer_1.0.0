# Node V 21.0.0, Java JDK 24, Gradle 8.14.3, node v22.17.0

"react": "19.1.0",
"react-native": "0.81.4",

.eslintrc.js
// module.exports = {
//   root: true,
//   extends: '@react-native',
//   rules: {
//     "@typescript-eslint/no-unused-vars": "off",
//   },
// };

10:00PM - 4:40AM = 6.40 hrs ------------ Sleep
4:40AM - 7AM = 2.20 hrs ---------------- Islam
7:00AM - 1:00PM = 6 hrs ---------------- Work
1:00PM - 2:00PM = 1 hr ----------------- Islam
2:00PM - 4:00PM = 2hrs ----------------- Sleep


"dependencies": {
"react": "19.1.0",
"react-native": "0.81.1",
"@react-native/new-app-screen": "0.81.1"k,
"react-native-safe-area-context": "^5.5.2"
},

# üìå POS Software Notes

## üîπ Industries

### ‚û°Ô∏è Retail

_italic text_  
bold text  
_bold & italic_  
~~strikethrough~~

> üí° This is an important note.

- Bullet Point 1
- Bullet Point 2
  - Sub bullet

1. Numbered item
2. Second item

- [x] Done task
- [ ] Pending task

| Industry    | Demand | Priority |
| ----------- | ------ | -------- |
| Retail      | High   | ‚úÖ       |
| Restaurants | High   | ‚úÖ       |
| Pharmacy    | Medium | üîÑ       |

`inline code`

3 Months project 90-days

------------This week task-------------------

------------This week task-------------------

---

# Ideas

1. Requirements Document (Ready-made)

# Other Software

1. Hotel management system
2. Hospital management system

# Target Industries

1. Restaurants / Caf√©s / QSR (Quick Service Restaurants)
2. Retail / General Stores / Supermarkets
3. Clothing & Apparel Stores / Boutiques
4. Pharmacies / Medical Stores
5. Bakeries / Sweet Shops
6. Salons / Spas / Beauty Parlors
7. Electronics & Mobile Shops
8. Liquor Stores / Wine Shops
9. Bookstores / Stationery Shops
10. Hardware & Home Improvement Stores
11. Jewelry Stores
12. Gyms / Fitness Centers
13. Pet Shops & Veterinary Clinics
14. Hotels / Hospitality
15. Gas Stations / Convenience Stores

üìä Key Insight:

- Restaurants and retail (general stores, supermarkets) are the top two industries globally where POS systems are sold the most.
- Clothing/fashion retail and pharmacies follow closely as strong verticals.

Do you want me to also give you the profitability ranking (which industries are willing to pay higher for POS features, not just adoption numbers)?

# Requirements

5 Registers
15 Users
1 Branch
Unlimited POS transactions
10000 Marketplace orders
5000 Purchase Orders & Bills
Everything in Professional +
Picklists
Custom Modules
Custom Buttons
Related Lists
Automation - Webhooks, Custom Functions, Schedulers
Developer Space - Incoming Webhooks, Connections
Shopify Integration (5 stores)
7500 API calls per day

1. Core POS Features

üîπ Billing & Invoicing

Fast checkout (barcode scanning, manual entry)
Print/email receipts
Multiple payment methods (Cash, Card, Mobile Wallets, QR, etc.)

üîπ Sales Management

Daily sales reports
Refunds, returns, and exchanges
Discounts & promotions
Customer loyalty & reward points

2. Inventory Management

Real-time stock tracking
Barcode generation & scanning
Low-stock alerts
Batch & expiry date tracking (important for pharmacies & food)
Multi-location / warehouse inventory

3. Customer Management (CRM)

Customer database (name, phone, purchase history)
Loyalty programs (points, cashback, discounts)
SMS/Email promotions integration

4. Employee & User Management

Role-based access (Admin, Cashier, Manager)
[x] Staff activity logs (who did what)
[x] Attendance & shift management
[x] Sales commission tracking

5. Reports & Analytics

Sales reports (daily, weekly, monthly, yearly)
Profit & loss statements
Inventory valuation reports
Best-selling items / slow-moving items
Tax reports (GST, VAT if applicable)

6. Multi-Store Management (if needed)

Centralized inventory control
Store-wise sales & profit reports
User access by branch
Price synchronization across outlets

7. Payment Integrations

Debit/Credit card support (via local gateways)
Mobile wallets (Easypaisa, JazzCash in Pakistan)
QR code payments
Cash drawer & receipt printer integration

8. Industry-Specific Features

üç¥ Restaurants & Cafes
Table & kitchen order management (KOT)
Online ordering integration (Foodpanda, etc.)
Menu management with add-ons

üíä Pharmacies

Expiry & batch tracking
Substitute medicine suggestion
Regulated drug reporting

üëó Retail/Fashion

Size/color/style matrix
Seasonal promotions
Exchange & returns handling

‚õΩ Petrol Pumps

Pump integration
Fuel price updates
Shift-wise settlement

9. Cloud & Offline Capabilities

Cloud-based dashboard (remote monitoring)
Works offline (syncs when internet is back)
Mobile POS app (Android/iOS)

10. Extra Add-ons (Advanced)

E-commerce integration (Shopify, WooCommerce, Daraz)
Accounting integration (QuickBooks, Xero, local ERP)
Supplier management & purchase orders
SMS/WhatsApp notifications for bills & promotions
Digital wallet support
QR-based customer self-checkout

------------------------------------------------------------Mobile App----------------------------------------------------------------------------

# Pakistan manufacture

1. Black copper
2. Nedo Coperation

Speed-X (via IT Bazar)

# Features

1. Product/Service Catalog

   - Add/edit products with name, category, price, barcode/QR code.
   - Import/export via Excel/CSV.

2. Billing & Invoicing

   - Quick bill creation (tap-to-add items).
   - Discount (item-level & bill-level).
   - Multiple payment methods (cash, card, mobile wallet, ‚Äúon credit‚Äù).
   - Thermal receipt printing via Bluetooth printer.
   - Share invoice by WhatsApp/SMS/Email (digital receipt).

3. Sales Management

   - Daily/weekly/monthly/yearly sales reports.
   - Top-selling products.
   - Pending payments / credit sales.
   - Tax/GST/VAT support (if needed in your region).

4. Customer Management

   - Save customer info (name, phone, balance).
   - Track credit sales & outstanding payments.
   - Customer purchase history.

5. Inventory Management
   - Stock in / stock out.
   - Low stock alerts.
   - Unit management (piece, kg, liter, etc.).
   - Option to scan barcodes with phone camera.

üîπ Good-to-Have Features (Added Value)

6. Multi-User / Staff Accounts

   - Cashier login vs Admin login.
   - Track sales by staff.

7. Analytics Dashboard

   - Daily profit/loss.
   - Expenses tracker.
   - Business performance charts.

8. Offline Mode

   - Work without internet ‚Üí auto sync when online.
   - Very important for small shops with weak internet.

9. Multi-Device Sync

   - Owner can see reports on another phone.
   - Data backup on cloud (Google Firebase / Supabase).

10. Printer Flexibility
    - Support 58mm & 80mm Bluetooth/USB printers (Black Copper, XPrinter, Sunmi, etc.).
    - Simple print templates (shop name, logo, tax info).

üîπ Advanced (Future Upgrade / Premium Plan)

11. Supplier & Purchase Management

    - Record purchases from suppliers.
    - Track due payments.

12. Loyalty / Membership System

    - Points per purchase.
    - Membership discounts.

13. E-commerce Link

    - Share digital product catalog to WhatsApp or a mini online store link.
    - Accept online orders.

14. Integration
    - Mobile wallets (Easypaisa, JazzCash, UPI).Accounting software (QuickBooks, Zoho, Odoo).

------------------------------------------------------------Mobile App----------------------------------------------------------------------------

# For Restaurants (Large)

üìåAudience: Owner, Cashier, Waiter boys, Kitchen boys, Customer, Delivery boys

1. Food CRUD

üìå For Owner:

1. Check active orders with table number
2. Earning reports
3. Staff Sallery
4. Product reports
5. Payment checkout

üìå For Customers:

1. Menu for Customers
2. Call a Waiter
3. Give Order(optonal)
   üìå For Waiter:
4. Order booking

üìå For Kitchen boys:

1.

# For Restaurants (Small)

1. Product CRUD
2. Transactions CRUD
3. Earning Reports
4. Best, Low stock product
5. Test print recepit

# Features

1. Connnect to printer
2. Test recepit

üìåInventory Management

1. CRUD of product

  const printReceipt1s = async () => {
    if (!connected) {
      return AppToast.error("Oops!", "Not connected to printer!");
    }

    try {
      // 0Ô∏è‚É£ Print logo first
      const imageUrl = `https://res.cloudinary.com/${Constant.CLOUDINARY_NAME}/image/upload/v1234567890/${user?.avatar}`;
      const localPath = `${RNFS.CachesDirectoryPath}/logo.png`;

      // Download the image locally
      const download = await RNFS.downloadFile({
        fromUrl: imageUrl,
        toFile: localPath,
      }).promise;

      if (download.statusCode === 200) {
        // ‚úÖ 2Ô∏è‚É£ Convert local image to base64
        const logoBase64 = await RNFS.readFile(localPath, "base64");

        // ‚úÖ 3Ô∏è‚É£ Print logo
        // Center logo on 58mm printer
        await BluetoothEscposPrinter.printPic(logoBase64, {
          width: 300, // image print width in dots (~37mm)
          left: 42, // center offset ( (384 - 300)/2 )
        });
      } else {
        console.warn("‚ö†Ô∏è Failed to download image:", download.statusCode);
      }

      // Print Shop Name
      const shopName = user?.name?.toUpperCase() || "SHOP NAME";

      // ‚úÖ Use your actual uploaded white image public ID
      const basePublicId = "user-uploads/1762095150573-blank_white";

      // ‚úÖ Create a text overlay (big bold black text)
      const textImageUrl = `https://res.cloudinary.com/${Constant.CLOUDINARY_NAME}/image/upload/l_text:Arial_100_bold:${encodeURIComponent(
        shopName,
      )},co_rgb:000000,b_white,w_384,c_fit/${basePublicId}.png`;



      const localPath2 = `${RNFS.CachesDirectoryPath}/shopName.png`;

      // Download the generated text image
      const download2 = await RNFS.downloadFile({
        fromUrl: textImageUrl,
        toFile: localPath2,
      }).promise;

      if (download2.statusCode === 200) {
        const shopNameBase64 = await RNFS.readFile(localPath2, "base64");

        // Print shop name image (large font)
        await BluetoothEscposPrinter.printPic(shopNameBase64, {
          width: 384, // full printer width
          left: 42, // center offset ( (384 - 300)/2 )
        });
      } else {
        console.warn("‚ö†Ô∏è Failed to download shop name:", download2.statusCode);
      }

      //  _________________________________
      // 2Ô∏è‚É£ Date and receipt number
      const date = new Date();
      const receiptNumber = Math.floor(Math.random() * 90000 + 10000);

      await BluetoothEscposPrinter.printerAlign(BluetoothEscposPrinter.ALIGN.LEFT);
      await BluetoothEscposPrinter.setBlob(1); // 1 = bold
      // await BluetoothEscposPrinter.printText(
      //   `${date.toLocaleDateString()} ${date.toLocaleTimeString()}\nReceipt: #${receiptNumber}\n\r`,
      //   { encoding: "GBK", align: BluetoothEscposPrinter.ALIGN.LEFT },
      // );
      await BluetoothEscposPrinter.printText(`Date: `, {});

      await BluetoothEscposPrinter.setBlob(0); // 1 = bold
      await BluetoothEscposPrinter.printText(`${date.toLocaleDateString()} ${date.toLocaleTimeString()}`, {
        encoding: "GBK",
        align: BluetoothEscposPrinter.ALIGN.LEFT,
      });

      await BluetoothEscposPrinter.setBlob(1);
      await BluetoothEscposPrinter.printText(`\nReceipt: `, {});

      await BluetoothEscposPrinter.setBlob(0);
      await BluetoothEscposPrinter.printText(`#${receiptNumber}\n\r`, { encoding: "GBK", align: BluetoothEscposPrinter.ALIGN.LEFT });

      await BluetoothEscposPrinter.printText("================================\n\r", {});

      // 3Ô∏è‚É£ Items
      let totalAmount = 0;
      const items = data.filter((p: any) => p.quantity > 0);

      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const lineTotal = item.quantity * item.sellingPrice;
        totalAmount += lineTotal;

        const line1 = `${item.name.padEnd(16)}\n\r`;
        const line2 = `${item.quantity.toString().padStart(3)} x ${item.sellingPrice.toFixed(2).padStart(5)} = ${lineTotal.toFixed(2)}\n\r`;

        await BluetoothEscposPrinter.setBlob(1); // bold for product name
        await BluetoothEscposPrinter.printText(line1, { encoding: "GBK" });

        await BluetoothEscposPrinter.setBlob(0); // normal for price line
        await BluetoothEscposPrinter.printText(line2, { encoding: "GBK" });

        // Print underline only between items, NOT after the last item
        if (i < items.length - 1) {
          await BluetoothEscposPrinter.printText("--------------------------------\n\r", {});
        }
      }

      // Print final total separator after the last item
      await BluetoothEscposPrinter.printText("================================\n\r", {});

      // 4Ô∏è‚É£ Total
      await BluetoothEscposPrinter.printerAlign(BluetoothEscposPrinter.ALIGN.RIGHT);
      await BluetoothEscposPrinter.printText(`Total: ${totalAmount.toFixed(2)}\n\r`, {
        encoding: "GBK",
        widthtimes: 2,
        heigthtimes: 2,
      });

      await BluetoothEscposPrinter.printerAlign(BluetoothEscposPrinter.ALIGN.RIGHT);
      await BluetoothEscposPrinter.printText(`Tax: ${totalAmount.toFixed(2)}\n\r`, {
        encoding: "GBK",
        widthtimes: 2,
        heigthtimes: 2,
      });

      await BluetoothEscposPrinter.printerAlign(BluetoothEscposPrinter.ALIGN.RIGHT);
      await BluetoothEscposPrinter.setBlob(1);
      await BluetoothEscposPrinter.printText(`Payable: ${totalAmount.toFixed(2)}\n\r`, {
        encoding: "GBK",
        widthtimes: 2,
        heigthtimes: 2,
      });

      // 6Ô∏è‚É£ Footer
      // await BluetoothEscposPrinter.setBlob(0);
      // await BluetoothEscposPrinter.printerAlign(BluetoothEscposPrinter.ALIGN.CENTER);
      // await BluetoothEscposPrinter.printText("\nThank you!\n\r\n\r", {
      //   encoding: "GBK",
      //   align: BluetoothEscposPrinter.ALIGN.CENTER,
      // });

      await BluetoothEscposPrinter.printText("\n\r", {});
      await BluetoothEscposPrinter.printText("\n\r", {});
      await BluetoothEscposPrinter.printText("\n\r", {});

      AppToast.success("Receipt printed successfully!");
    } catch (err) {
      console.warn(err);

      AppToast.error("Oops!", "Printing failed!!");
      dispatch(setPrinterDisconnected());
    }
  };

  const printReceipt1 = async () => {
    try {
      await BluetoothEscposPrinter.printerInit();
      await BluetoothEscposPrinter.printerAlign(BluetoothEscposPrinter.ALIGN.CENTER);

      // --- Print Logo ---
      const logoPublicId =
        "user-uploads/1762078008281-Hamza_Hameed_Minimalist_black-and-white_logo_for_a_restaurant_featuring_a_for_57e98f5c-591c-46b3-9f5a-2820b9a1b3b7.png";
      const logoUrl = `https://res.cloudinary.com/${Constant.CLOUDINARY_NAME}/image/upload/c_fit,w_280/${logoPublicId}`;
      const logoPath = `${RNFS.CachesDirectoryPath}/shopLogo.png`;

      const logoRes = await RNFS.downloadFile({ fromUrl: logoUrl, toFile: logoPath }).promise;
      if (logoRes.statusCode === 200) {
        const base64Logo = await RNFS.readFile(logoPath, "base64");
        await BluetoothEscposPrinter.printPic(base64Logo, { width: 384, left: 0 });
      }

      // --- Print Big Shop Name (rendered via Cloudinary) ---
      const shopName = (user?.name || "SHOP NAME").toUpperCase();
      //  ‚ùóÔ∏èUse the same blank white background you uploaded earlier
      const basePublicId = "user-uploads/1762095150573-blank_white";

      const textImageUrl = `https://res.cloudinary.com/${Constant.CLOUDINARY_NAME}/image/upload/l_text:Arial_150_bold:${encodeURIComponent(
        shopName,
      )},co_rgb:000000,b_white,w_384,c_fit/${basePublicId}.png`;

      const namePath = `${RNFS.CachesDirectoryPath}/shopNameImage.png`;
      const textRes = await RNFS.downloadFile({ fromUrl: textImageUrl, toFile: namePath }).promise;

      if (textRes.statusCode === 200) {
        const shopNameBase64 = await RNFS.readFile(namePath, "base64");
        await BluetoothEscposPrinter.printPic(shopNameBase64, { width: 384, left: 0 });
      } else {
        console.warn("‚ö†Ô∏è Failed to download shop name image:", textRes.statusCode);
      }

      // Optional tiny space after header
      await BluetoothEscposPrinter.printAndFeed(1);
    } catch (err) {

    }
  };

  const printReceipts = async () => {
    try {


      const printer: any = connectedPrinter;

      // Step 1Ô∏è‚É£: Ensure printer is connected
      // if (!(await printer.isConnected())) {
      //   await printer.connect({ timeout: 5000, encoding: "UTF-8" });
      //   console.log("‚úÖ Printer reconnected:", printer.device?.name ?? printer.id);
      // }

      // Step 2Ô∏è‚É£: Download logo image from Cloudinary
      const logoPublicId =
        "user-uploads/1762078008281-Hamza_Hameed_Minimalist_black-and-white_logo_for_a_restaurant_featuring_a_for_57e98f5c-591c-46b3-9f5a-2820b9a1b3b7.png";
      const logoUrl = `https://res.cloudinary.com/${Constant.CLOUDINARY_NAME}/image/upload/c_fit,w_384/${logoPublicId}`;
      const logoPath = `${RNFS.CachesDirectoryPath}/receipt_logo.png`;

      const logoRes = await RNFS.downloadFile({ fromUrl: logoUrl, toFile: logoPath }).promise;
      if (logoRes.statusCode !== 200) throw new Error("Failed to download logo image");

      const logoBase64 = await RNFS.readFile(logoPath, "base64");

      // Step 3Ô∏è‚É£: Print logo (centered, full width)
      await printer.printImage(logoBase64, { align: "CENTER", width: 384 });

      // Step 4Ô∏è‚É£: Print big shop name immediately (no extra feed)
      const shopName = (user?.name || "SHOP NAME").toUpperCase();
      await printer.printText(shopName, { align: "CENTER", size: 48, bold: true });

      // Step 5Ô∏è‚É£: Optional spacing / contact info
      await printer.printText("\n", { align: "CENTER" });



      // Step 6Ô∏è‚É£: Do not disconnect if you want persistent connection
      // await printer.disconnect();
    } catch (err) {
      console.error("‚ùå Print error:", err);
    }
  };

  const printReceipt3 = async () => {
    const printer = connectedPrinter;

    try {
      // Step 1Ô∏è‚É£: Print logo (download & convert to base64)
      const logoUrl = "https://i.ibb.co/21dsjpLx/image-23-2.png"; // replace with your logo
      const logoPath = `${RNFS.CachesDirectoryPath}/receipt_logo.png`;
      const logoRes = await RNFS.downloadFile({ fromUrl: logoUrl, toFile: logoPath }).promise;
      if (logoRes.statusCode === 200) {
        const logoBase64 = await RNFS.readFile(logoPath, "base64");
        await printer.printImageBase64(logoBase64, { imageWidth: 384 });
      }

      // Step 2Ô∏è‚É£: Print shop name
      const shopName = (user?.name || "SHOP NAME").toUpperCase();
      await printer.printText(COMMANDS.TEXT_FORMAT.TXT_ALIGN_CT + COMMANDS.TEXT_FORMAT.TXT_BOLD_ON + shopName + "\n");

      // Step 3Ô∏è‚É£: Print horizontal line
      await printer.printText(COMMANDS.HORIZONTAL_LINE.HR_58MM + "\n");

      // Step 4Ô∏è‚É£: Print order items in columns
      const header = ["Item", "Qty", "Price"];
      const columnWidth = [20, 6, 12]; // adjust for your printer width
      const columnAlignment: ColumnAlignment[] = [ColumnAlignment.LEFT, ColumnAlignment.CENTER, ColumnAlignment.RIGHT];

      // Print header
      await printer.printColumnsText(header, columnWidth, columnAlignment, [COMMANDS.TEXT_FORMAT.TXT_BOLD_ON, "", ""]);

      // Print items
      for (const item of orderList) {
        await printer.printColumnsText([item.name, `x${item.qty}`, item.price], columnWidth, columnAlignment, [
          COMMANDS.TEXT_FORMAT.TXT_BOLD_OFF,
          "",
          "",
        ]);
      }

      // Step 5Ô∏è‚É£: Print total & thank you message
      const totalPrice = orderList.reduce((sum, item) => sum + parseFloat(item.price.replace(/[^0-9.-]+/g, "")), 0);
      await printer.printText(COMMANDS.HORIZONTAL_LINE.HR_58MM + "\n");
      await printer.printColumnsText(["TOTAL", "", `$${totalPrice.toFixed(2)}`], columnWidth, columnAlignment, [
        COMMANDS.TEXT_FORMAT.TXT_BOLD_ON,
        "",
        "",
      ]);
      await printer.printText(COMMANDS.TEXT_FORMAT.TXT_ALIGN_CT + "\nThank you for your purchase!\n\n");


    } catch (err) {
      console.error("‚ùå Print error:", err);
    }
  };

  const printReceipt4 = async () => {
    try {
      const Printer = connectedPrinter;

      const BOLD_ON = COMMANDS.TEXT_FORMAT.TXT_BOLD_ON;
      const BOLD_OFF = COMMANDS.TEXT_FORMAT.TXT_BOLD_OFF;
      const CENTER = COMMANDS.TEXT_FORMAT.TXT_ALIGN_CT;
      let orderList = [
        ["1. Skirt Palas Labuh Muslimah Fashion", "x2", "500$"],
        ["2. BLOUSE ROPOL VIRAL MUSLIMAH FASHION ", "x4222", "12.333.500$"],
        ["3. Women Crew Neck Button Down Ruffle Collar Loose Blouse", "x1", "30000000000000$"],
      ];
      let columnAlignment = [ColumnAlignment.LEFT, ColumnAlignment.CENTER, ColumnAlignment.RIGHT];
      let columnWidth = [48 - (7 + 12), 7, 12];
      const header = ["Product list", "Qty", "Price"];
      Printer.printImage("https://i.ibb.co/21dsjpLx/image-23-2.png", { imageWidth: 400 });
      Printer.printColumnsText(header, columnWidth, columnAlignment, [`${BOLD_ON}`, "", ""]);
      for (let i in orderList) {
        Printer.printColumnsText(orderList[i], columnWidth, columnAlignment, [`${BOLD_OFF}`, "", ""]);
      }
      Printer.printBill(`${CENTER}Thank you\n`);
    } catch (err) {
      console.warn("Print bill error" + err);
    }
  };

  export var BLEPrinter = {
    init: function () {
        return new Promise(function (resolve, reject) {
            return RNBLEPrinter.init(function () { return resolve(); }, function (error) { return reject(error); });
        });
    },
    getDeviceList: function () {
        return new Promise(function (resolve, reject) {
            return RNBLEPrinter.getDeviceList(function (printers) { return resolve(printers); }, function (error) { return reject(error); });
        });
    },
    connectPrinter: function (inner_mac_address) {
        return new Promise(function (resolve, reject) {
            return RNBLEPrinter.connectPrinter(inner_mac_address, function (printer) { return resolve(printer); }, function (error) { return reject(error); });
        });
    },
    closeConn: function () {
        return new Promise(function (resolve) {
            RNBLEPrinter.closeConn();
            resolve();
        });
    },
    printText: function (text, opts) {
        if (opts === void 0) { opts = {}; }
        if (Platform.OS === "ios") {
            var processedText = textPreprocessingIOS(text);
            RNBLEPrinter.printRawData(processedText.text, processedText.opts, function (error) { return console.warn(error); });
        }
        else {
            RNBLEPrinter.printRawData(textTo64Buffer(text, opts), function (error) {
                return console.warn(error);
            });
        }
    },
    printBill: function (text, opts) {
        if (opts === void 0) { opts = {}; }
        if (Platform.OS === "ios") {
            var processedText = textPreprocessingIOS(text);
            RNBLEPrinter.printRawData(processedText.text, processedText.opts, function (error) { return console.warn(error); });
        }
        else {
            RNBLEPrinter.printRawData(billTo64Buffer(text, opts), function (error) {
                return console.warn(error);
            });
        }
    },
};

  connectPrinter: function (inner_mac_address) {
        return new Promise(function (resolve, reject) {
            return RNBLEPrinter.connectPrinter(inner_mac_address, function (printer) { return resolve(printer); }, function (error) { return reject(error); });
        });
    },

    
// import React, { useEffect, useState } from "react";
// import { View, TouchableOpacity, ActivityIndicator, Platform, PermissionsAndroid, NativeModules } from "react-native";
// import { useRoute } from "@react-navigation/native";
// import Ionicons from "@react-native-vector-icons/ionicons";
// import { useDispatch, useSelector } from "react-redux";

// import { DEVICE_PRINTER } from "@haroldtran/react-native-thermal-printer";
// import AppIcon from "../AppIcon";
// import DashboardSidebar from "./DashboardSidebar";
// import { ThemedText } from "../../widgets/ThemeText";
// import { setPrinterConnected, setPrinterDisconnected } from "@/src/redux/slices/printerSlice";
// import AppToast from "@/src/widgets/CustomToast";
// import { Helper } from "@/src/utils/Helper";
// const { BluetoothManager } = NativeModules;
// import BleManager from "react-native-ble-manager";

// // üîπ Global printer ref
// export let connectedPrinter: any = null;

// // ‚úÖ Android 12+ permission helper
// async function requestBluetoothPermissions() {
//   if (Platform.OS === "android" && Platform.Version >= 31) {
//     const granted = await PermissionsAndroid.requestMultiple([
//       PermissionsAndroid.PERMISSIONS.BLUETOOTH_CONNECT,
//       PermissionsAndroid.PERMISSIONS.BLUETOOTH_SCAN,
//       PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
//     ]);
//     const allGranted = Object.values(granted).every(v => v === PermissionsAndroid.RESULTS.GRANTED);
//     if (!allGranted) throw new Error("Bluetooth permissions not granted");
//   }
// }

// export default function TopNav() {
//   const [showDrawer, setShowDrawer] = useState(false);
//   const [loading, setLoading] = useState(true);
//   const route = useRoute();
//   const dispatch = useDispatch();
//   const { connected, address } = useSelector((state: any) => state.printer);

//   // ‚úÖ On mount ‚Üí check if printer is connected
//   useEffect(() => {
//     checkPrinterConnection();
//   }, []);

//   /** üîç Just verify existing connection */
//   /** üîç Just verify existing connection */
//   const checkPrinterConnection = async () => {
//     try {
//       setLoading(true);
//       console.log("üîç Checking printer connection...");

//       const printer: any = DEVICE_PRINTER?.["ble"];

//       if (!printer || !printer.init) {
//         console.warn("‚ùå BLE printer module not loaded.");
//         return;
//       }

//       // Initialize BLE safely
//       try {
//         await printer.init();
//       } catch (err) {
//         console.warn("‚ö†Ô∏è Printer init failed:", err);
//         return;
//       }

//       // Wait a moment ‚Äî some BLE stacks crash if scanned too fast
//       await new Promise(res => setTimeout(res, 800));

//       let devices = [];
//       try {
//         devices = await printer.getDeviceList();
//         console.log("üì° Found devices:", devices);
//       } catch (err) {
//         console.warn("‚ö†Ô∏è Failed to get device list:", err);
//         return;
//       }

//       if (!devices || devices.length === 0) {
//         console.warn("‚ö†Ô∏è No BLE printers found.");
//         dispatch(setPrinterDisconnected());
//         return;
//       }

//       const selectedDevice = devices[0];
//       if (!selectedDevice?.inner_mac_address) {
//         console.warn("‚ö†Ô∏è Device has no MAC address, skipping connect.");
//         dispatch(setPrinterDisconnected());
//         return;
//       }

//       // ‚úÖ Try connecting but wrap in JS timeout ‚Äî prevents infinite native hang
//       const connectSafe = async () => {
//         return Promise.race([
//           // Try to connect printer
//           (async () => {
//             const res = await printer.connectPrinter(selectedDevice.inner_mac_address);
//             console.log("‚úÖ Printer connected result:", res);
//             return res;
//           })(),
//           // Timeout after 5 seconds
//           new Promise((_, reject) => setTimeout(() => reject(new Error("connect timeout")), 10000)),
//         ]);
//       };

//       try {
//         await connectSafe();
//         connectedPrinter = printer;
//         dispatch(setPrinterConnected(selectedDevice.inner_mac_address));
//         console.log("‚úÖ Connected to printer:", selectedDevice.device_name);
//       } catch (err) {
//         console.warn("‚ùå Failed to connect:", err);
//         connectedPrinter = null;
//         dispatch(setPrinterDisconnected());
//       }
//     } catch (err) {
//       console.warn("‚ùå Uncaught printer check error:", err);
//       connectedPrinter = null;
//       dispatch(setPrinterDisconnected());
//     } finally {
//       setLoading(false);
//     }
//   };

//   return (
//     <View className="flex-row items-center justify-between px-4 py-3 bg-base-100 border-b border-base-content/10">
//       {/* Left Drawer Icon */}
//       <TouchableOpacity onPress={() => setShowDrawer(true)}>
//         <AppIcon IconComponent={Ionicons} name="menu-outline" size={30} className="text-base-content-70" />
//       </TouchableOpacity>

//       <DashboardSidebar showDrawer={showDrawer} setShowDrawer={setShowDrawer} />

//       {/* Title */}
//       <ThemedText className="text-lg font-grotes-bold text-base-content">{route.name || "Dashboard"}</ThemedText>

//       <TouchableOpacity onPress={checkPrinterConnection} className="p-2 rounded-full bg-base-200 relative flex-row items-center justify-center">
//         {loading ? (
//           <ActivityIndicator size="small" color="#00D390" />
//         ) : (
//           <View className="relative">
//             <AppIcon
//               IconComponent={Ionicons}
//               name={connected ? "checkmark-circle-outline" : "close-circle-outline"}
//               size={14}
//               className={`${connected ? "text-success" : "text-error"} absolute -top-2 -right-2`}
//             />
//             <AppIcon IconComponent={Ionicons} name="print" size={28} className={`${connected ? "text-success" : "text-error"}`} />
//           </View>
//         )}
//       </TouchableOpacity>
//     </View>
//   );
// }

// import React, { useEffect, useState } from "react";
// import { View, TouchableOpacity, Alert, ActivityIndicator } from "react-native";
// import { useRoute } from "@react-navigation/native";
// import Ionicons from "@react-native-vector-icons/ionicons";
// import AsyncStorage from "@react-native-async-storage/async-storage";
// import { BluetoothManager } from "react-native-bluetooth-escpos-printer";
// import { useDispatch, useSelector } from "react-redux";

// import AppIcon from "../AppIcon";
// import DashboardSidebar from "./DashboardSidebar";
// import { ThemedText } from "../../widgets/ThemeText";
// import { RootState } from "@/src/redux/store";
// import { setPrinterConnected, setPrinterDisconnected } from "@/src/redux/slices/printerSlice";
// import { DEVICE_PRINTER } from "@haroldtran/react-native-thermal-printer";
// import { Helper } from "@/src/utils/Helper";

// export let connectedPrinter: any = null;

// export default function TopNav({ onNotificationsPress }: any) {
//   const [showDrawer, setShowDrawer] = useState(false);
//   const [loading, setLoading] = useState(true);
//   const route = useRoute();
//   const dispatch = useDispatch();

//   const { connected, printerAddress } = useSelector((state: any) => state.printer);

//   useEffect(() => {
//     autoConnectPrinter();
//   }, []);

//    // ‚úÖ On mount ‚Üí check if printer is connected
//   useEffect(() => {
//     checkPrinterConnection();
//   }, []);

//   /** üîç Just verify existing connection */
//   /** üîç Just verify existing connection */
//   const checkPrinterConnection = async () => {
//     try {
//       setLoading(true);
//       console.log("üîç Checking printer connection...");

//       const printer: any = DEVICE_PRINTER?.["ble"];

//       if (!printer || !printer.init) {
//         console.warn("‚ùå BLE printer module not loaded.");
//         return;
//       }

//       // Initialize BLE safely
//       try {
//         await printer.init();
//       } catch (err) {
//         console.warn("‚ö†Ô∏è Printer init failed:", err);
//         return;
//       }

//       // Wait a moment ‚Äî some BLE stacks crash if scanned too fast
//       await new Promise(res => setTimeout(res, 800));

//       let devices = [];
//       try {
//         devices = await printer.getDeviceList();
//         console.log("üì° Found devices:", devices);
//       } catch (err) {
//         console.warn("‚ö†Ô∏è Failed to get device list:", err);
//         return;
//       }

//       if (!devices || devices.length === 0) {
//         console.warn("‚ö†Ô∏è No BLE printers found.");
//         dispatch(setPrinterDisconnected());
//         return;
//       }

//       const selectedDevice = devices[0];
//       if (!selectedDevice?.inner_mac_address) {
//         console.warn("‚ö†Ô∏è Device has no MAC address, skipping connect.");
//         dispatch(setPrinterDisconnected());
//         return;
//       }

//       // ‚úÖ Try connecting but wrap in JS timeout ‚Äî prevents infinite native hang
//       const connectSafe = async () => {
//         return Promise.race([
//           // Try to connect printer
//           (async () => {
//             const res = await printer.connectPrinter(selectedDevice.inner_mac_address);
//             console.log("‚úÖ Printer connected result:", res);
//             return res;
//           })(),
//           // Timeout after 5 seconds
//           new Promise((_, reject) => setTimeout(() => reject(new Error("connect timeout")), 10000)),
//         ]);
//       };

//       try {
//         await connectSafe();
//         connectedPrinter = printer;
//         dispatch(setPrinterConnected(selectedDevice.inner_mac_address));
//         console.log("‚úÖ Connected to printer:", selectedDevice.device_name);
//       } catch (err) {
//         console.warn("‚ùå Failed to connect:", err);
//         connectedPrinter = null;
//         dispatch(setPrinterDisconnected());
//       }
//     } catch (err) {
//       console.warn("‚ùå Uncaught printer check error:", err);
//       connectedPrinter = null;
//       dispatch(setPrinterDisconnected());
//     } finally {
//       setLoading(false);
//     }
//   };

//   /** üîÑ Auto connect to saved or paired printer */
//   const autoConnectPrinter = async () => {
//     try {
//       setLoading(true);

//       // Get last saved printer address (from Redux or AsyncStorage)
//       const savedAddress = printerAddress || (await AsyncStorage.getItem("lastPrinterAddress"));
//       await BluetoothManager.enableBluetooth();

//       if (savedAddress) {
//         try {
//           await BluetoothManager.connect(savedAddress);
//           dispatch(setPrinterConnected(savedAddress));
//           await AsyncStorage.setItem("lastPrinterAddress", savedAddress);
//           console.log("‚úÖ Auto-connected to printer:", savedAddress);
//           return;
//         } catch (err) {
//           console.warn("‚ö†Ô∏è Failed to reconnect saved printer:", err);
//           dispatch(setPrinterDisconnected());
//         }
//       }

//       // Fallback ‚Äî try first paired printer
//       const devices = await BluetoothManager.scanDevices();
//       const parsed = typeof devices === "string" ? JSON.parse(devices) : devices;
//       const paired = parsed?.paired || [];

//       if (paired.length > 0) {
//         const firstPrinter = paired[0];
//         await BluetoothManager.connect(firstPrinter.address);
//         dispatch(setPrinterConnected(firstPrinter.address));
//         await AsyncStorage.setItem("lastPrinterAddress", firstPrinter.address);
//         console.log("‚úÖ Connected to first paired printer:", firstPrinter.name);
//       } else {
//         console.log("‚ö†Ô∏è No paired printers found.");
//         dispatch(setPrinterDisconnected());
//       }
//     } catch (error) {
//       dispatch(setPrinterDisconnected());
//     } finally {
//       setLoading(false);
//     }
//   };

//   /** üîÅ Manual reconnect */
//   const handleReconnect = async () => {
//     dispatch(setPrinterDisconnected());
//     await autoConnectPrinter();
//   };

//   return (
//     <View className="flex-row items-center justify-between px-4 py-3 bg-base-100 border-b border-base-content/10">
//       {/* Left Drawer Icon */}
//       <TouchableOpacity onPress={() => setShowDrawer(true)}>
//         <AppIcon IconComponent={Ionicons} name="menu-outline" size={30} className="text-base-content-70" />
//       </TouchableOpacity>

//       <DashboardSidebar showDrawer={showDrawer} setShowDrawer={setShowDrawer} />

//       {/* Title */}
//       <ThemedText className="text-lg font-grotes-bold text-base-content">{route.name || "Dashboard"}</ThemedText>

//       {/* Printer / Reconnect */}
//       <TouchableOpacity onPress={handleReconnect} className="p-2 rounded-full bg-base-200 relative flex-row items-center justify-center">
//         {loading ? (
//           <ActivityIndicator size="small" color="#00D390" />
//         ) : (
//           <View className="relative">
//             <AppIcon
//               IconComponent={Ionicons}
//               name={connected ? "checkmark-circle-outline" : "close-circle-outline"}
//               size={14}
//               className={`${connected ? "text-success" : "text-error"} absolute -top-2 -right-2`}
//             />
//             <AppIcon IconComponent={Ionicons} name="print" size={28} className={`${connected ? "text-success" : "text-error"}`} />
//           </View>
//         )}
//       </TouchableOpacity>
//     </View>
//   );
// }
